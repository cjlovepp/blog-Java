>多线程作为Java中一个很重要的内容经常被应用于各种场景中，包括再面试的时候这方面的知识也是面试官们的热爱，在此结合网上的blog和个人的学习做下总结记录。本文主要讲了java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别：
<br>
 **进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）**
<br>
 **线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）**


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
* [目录]()
* [一、线程的生命周期及五种基本的状态](#一-线程的生命周期及五种基本的状态)
* [二、Java多线程的创建及启动](#二-java多线程的创建及启动)
	* [1、 扩展java.lang.Thrad类](#1-扩展javalangthrad类)
	* [2、 实现java.lang.Runnable接口](#2-实现javalangrunnable接口)
	* [3、Thread和Runnable的区别](#3-thread和runnable的区别)

<!-- /code_chunk_output -->

----------

## 一、线程的生命周期及五种基本的状态
>关于Java中线程的生命周期在网上找到一张经典的图

![232002051747387](/assets/232002051747387.jpg)

上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：

1. **新建状态（New）：** 当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();
<br>

2. **就绪状态（Runnable）：** 当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；
<br>

3. **运行状态（Running）：** 当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；
<br>

4. **阻塞状态（Blocked）：** 处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：

		*等待阻塞 --* 运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
		*同步阻塞 --* 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；
		*其他阻塞 --* 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
<br>

5. **死亡状态（Dead）：** 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
---------------

## 二、Java多线程的创建及启动
>在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用。这个在之后做单独记录)

### 1、 扩展java.lang.Thrad类
```java
public Thread1 extends Thread{
	private String name;
	public Thread1(String name){
		this.name = name;
	}

	public void run(){
		for(int i= 0; i<5; i++){
			System.out.println(name+"运行"+i);
			try{
				sleep((int) Math.random() * 10);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
}

public class Main{
	public static void main(String[] args) {
		Thread1 mTh1 = new Thread1("A");
		Thread1 mTh2 = new Thread1("B");
		mTh1.start();
		mTh2.start();
	}
}
```
输出：
A运行  :  0
B运行  :  0
A运行  :  1
A运行  :  2
A运行  :  3
A运行  :  4
B运行  :  1
B运行  :  2
B运行  :  3
B运行  :  4

再次运行：
A运行  :  0
B运行  :  0
B运行  :  1
B运行  :  2
B运行  :  3
B运行  :  4
A运行  :  1
A运行  :  2
A运行  :  3
A运行  :  4

说明：
程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。

**注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。**

从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。
Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。
实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。

但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。
```java
Thread1 mTh1=new Thread1("A");
Thread1 mTh2=mTh1;
mTh1.start();
mTh2.start();
```
输出：
>Exception in thread "main" java.lang.IllegalThreadStateException
    at java.lang.Thread.start(Unknown Source)
    at com.multithread.learning.Main.main(Main.java:31)
		<br>
A运行  :  0
A运行  :  1
A运行  :  2
A运行  :  3
A运行  :  4

### 2、 实现java.lang.Runnable接口
```java
class Thread2 implements Runnable{
	private String name;

	public Thread2(String name) {
		this.name=name;
	}

	@Override
	public void run() {
		  for (int i = 0; i < 5; i++) {
	            System.out.println(name + "运行  :  " + i);
	            try {
	            	Thread.sleep((int) Math.random() * 10);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	        }

	}

}
public class Main {

	public static void main(String[] args) {
		new Thread(new Thread2("C")).start();
		new Thread(new Thread2("D")).start();
	}

}
```
输出：
C运行  :  0
D运行  :  0
D运行  :  1
C运行  :  1
D运行  :  2
C运行  :  2
D运行  :  3
C运行  :  3
D运行  :  4
C运行  :  4

说明：
Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。
在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。
实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。

### 3、Thread和Runnable的区别
如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。
```java
/**
 *@functon 多线程学习,继承Thread，资源不能共享
 *@time 2015.3.9
 */
class Thread1 extends Thread{
	private int count=5;
	private String name;
    public Thread1(String name) {
       this.name=name;
    }
	public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(name + "运行  count= " + count--);
            try {
                sleep((int) Math.random() * 10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

	}
}

public class Main {

	public static void main(String[] args) {
		Thread1 mTh1=new Thread1("A");
		Thread1 mTh2=new Thread1("B");
		mTh1.start();
		mTh2.start();

	}

}
```
输出：
B运行  count= 5
A运行  count= 5
B运行  count= 4
B运行  count= 3
B运行  count= 2
B运行  count= 1
A运行  count= 4
A运行  count= 3
A运行  count= 2
A运行  count= 1

从上面可以看出，不同的线程之间count是不同的，这对于卖票系统来说就会有很大的问题，当然，这里可以用同步来作。这里我们用Runnable来做下看看
```java
/**
 *@functon 多线程学习 继承runnable，资源能共享
 *@author 林炳文
 *@time 2015.3.9
 */
package com.multithread.runnable;
class Thread2 implements Runnable{
    private int count=15;
	@Override
	public void run() {
		  for (int i = 0; i < 5; i++) {
			  System.out.println(Thread.currentThread().getName() + "运行  count= " + count--);
	            try {
	            	Thread.sleep((int) Math.random() * 10);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	        }

	}

}
public class Main {

	public static void main(String[] args) {

		Thread2 my = new Thread2();
	        new Thread(my, "C").start();//同一个mt，但是在Thread中就不可以，如果用同一个实例化对象mt，就会出现异常
	        new Thread(my, "D").start();
	        new Thread(my, "E").start();
	}

}
```
输出：
C运行  count= 15
D运行  count= 14
E运行  count= 13
D运行  count= 12
D运行  count= 10
D运行  count= 9
D运行  count= 8
C运行  count= 11
E运行  count= 12
C运行  count= 7
E运行  count= 6
C运行  count= 5
E运行  count= 4
C运行  count= 3
E运行  count= 2

这里要注意每个线程都是用同一个实例化对象，如果不是同一个，效果就和上面的一样了！

总结：

实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立


提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。



在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ实习在就是在操作系统中启动了一个进程。



![参考博文][http://www.mamicode.com/info-detail-517008.html]
