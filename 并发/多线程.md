>多线程作为Java中一个很重要的内容经常被应用于各种场景中，包括再面试的时候这方面的知识也是面试官们的热爱，在此结合网上的blog和个人的学习做下总结记录。本文主要讲了java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别：
>> **进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）**
>> **线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）**


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
* [目录]()
* [一、线程的生命周期及五种基本的状态](#一-线程的生命周期及五种基本的状态)
* [二、Java多线程的创建及启动](#二-java多线程的创建及启动)
	* [1、 扩展java.lang.Thrad类](#1-扩展javalangthrad类)

<!-- /code_chunk_output -->

---

## 一、线程的生命周期及五种基本的状态
>关于Java中线程的生命周期在网上找到一张经典的图

![232002051747387](/assets/232002051747387.jpg)
上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：

1. **新建状态（New）：** 当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();
<br>
2. **就绪状态（Runnable）：** 当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；
<br>
3. **运行状态（Running）：** 当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；
<br>
4. **阻塞状态（Blocked）：** 处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：
		*等待阻塞 --* 运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
		*同步阻塞 --* 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；
		*其他阻塞 --* 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
<br>
5. **死亡状态（Dead）：** 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
---

## 二、Java多线程的创建及启动
>在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用。这个在之后做单独记录)

### 1、 扩展java.lang.Thrad类
```java
public Thread1 extends Thread{
	private String name;
	public Thread1(String name){
		this.name = name;
	}

	public void run(){
		for(int i= 0; i<5; i++){
			System.out.println(name+"运行"+i);
			try{
				sleep((int) Math.random() * 10);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
}

public class Main{
	public static void main(String[] args) {
		Thread1 mTh1 = new Thread1("A");
		Thread1 mTh2 = new Thread1("B");
		mTh1.start();
		mTh2.start();
	}
}
```
输出：
>A运行  :  0
B运行  :  0
A运行  :  1
A运行  :  2
A运行  :  3
A运行  :  4
B运行  :  1
B运行  :  2
B运行  :  3
B运行  :  4

再次运行：
>A运行  :  0
B运行  :  0
B运行  :  1
B运行  :  2
B运行  :  3
B运行  :  4
A运行  :  1
A运行  :  2
A运行  :  3
A运行  :  4

说明：
程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。
**注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。**
从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。
Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。
实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。

但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。
```java
Thread1 mTh1=new Thread1("A");
Thread1 mTh2=mTh1;
mTh1.start();
mTh2.start();
```
输出：
>Exception in thread "main" java.lang.IllegalThreadStateException
    at java.lang.Thread.start(Unknown Source)
    at com.multithread.learning.Main.main(Main.java:31)
A运行  :  0
A运行  :  1
A运行  :  2
A运行  :  3
A运行  :  4
